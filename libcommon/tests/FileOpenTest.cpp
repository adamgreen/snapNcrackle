/*  Copyright (C) 2013  Adam Green (https://github.com/adamgreen)

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*/
#include <string.h>

// Include headers from C modules under test.
extern "C"
{
    #include "FileOpen.h"
    #include "MallocFailureInject.h"
    #include "util.h"
}

// Include C++ headers for test harness.
#include "CppUTest/TestHarness.h"

#define TEST_FILENAME "FileOpenTest.tst"

const char  g_testContent[] = "Test Content\n";

TEST_GROUP(FileOpen)
{
    FILE*       m_pFile;
    const char* m_pFilename;

    void setup()
    {
        m_pFile = NULL;
        m_pFilename = NULL;
        clearExceptionCode();
    }

    void teardown()
    {
        MallocFailureInject_Restore();
        if (m_pFile)
            fclose(m_pFile);
        if (m_pFilename)
            remove(m_pFilename);
        remove(TEST_FILENAME);
        free((void*)m_pFilename);
        LONGS_EQUAL(noException, getExceptionCode());
    }
    
    void createTestFile(const char* pFilename = TEST_FILENAME)
    {
        FILE* pFile = fopen(pFilename, "wb");
        fwrite(g_testContent, 1, sizeof(g_testContent), pFile);
        fclose(pFile);
        m_pFilename = strdup(pFilename);
    }
    
    char* strdup(const char* p)
    {
        size_t len = strlen(p) + 1;
        char* pDupe = (char*)malloc(len);
        memcpy(pDupe, p, len);
        
        return pDupe;
    }
    
    void validateTestFileContents()
    {
        char buffer[sizeof(g_testContent)];
        
        CHECK(NULL != m_pFile);
        size_t bytesRead = fread(buffer, 1, sizeof(buffer), m_pFile);
        LONGS_EQUAL(sizeof(buffer), bytesRead);
        STRCMP_EQUAL(g_testContent, buffer);
    }
};


TEST(FileOpen, AttemptToOpenForReadNonExistingFile)
{
    m_pFile = FileOpen(TEST_FILENAME, "rb");
    POINTERS_EQUAL(NULL, m_pFile);
}

TEST(FileOpen, OpenNonExistingFileForWrite)
{
    m_pFile = FileOpen(TEST_FILENAME, "wb");
    CHECK(m_pFile != NULL);
}

TEST(FileOpen, OpenExistingFileForReadWithSameCase)
{
    createTestFile();
    m_pFile = FileOpen(TEST_FILENAME, "rb");
    validateTestFileContents();
}

TEST(FileOpen, OpenExistingFileForReadWithDifferentCase)
{
    createTestFile();
    m_pFile = FileOpen("FILEOPENTEST.TST", "rb");
    validateTestFileContents();
}

TEST(FileOpen, OpenExistingFileForReadWithDifferentCaseAndDirectoryNameSpecified)
{
    createTestFile();
    m_pFile = FileOpen("." SLASH_STR "FILEOPENTEST.TST", "rb");
    validateTestFileContents();
}

TEST(FileOpen, OpenExistingFileForReadInSubdirectory)
{
    createTestFile("objs" SLASH_STR TEST_FILENAME );
    m_pFile = FileOpen("objs" SLASH_STR TEST_FILENAME, "rb");
    validateTestFileContents();
}

TEST(FileOpen, OpenExistingFileForReadInSubdirectoryWithDifferentCase)
{
    createTestFile("objs" SLASH_STR TEST_FILENAME );
    m_pFile = FileOpen("objs" SLASH_STR "fileopentest.tst", "rb");
    validateTestFileContents();
}

TEST(FileOpen, AttemptToOpenForReadInInvalidDirectory)
{
    createTestFile();
    m_pFile = FileOpen("foo.bar" SLASH_STR TEST_FILENAME, "rb");
    POINTERS_EQUAL(NULL, m_pFile);
}

TEST(FileOpen, AttemptToOpenADirectoryNameThatIsTooLong)
{
    char filename[257+1+1+1];
    
    memset(filename, 'a', sizeof(filename));
    filename[257] = PATH_SEPARATOR;
    filename[258] = 'a';
    filename[259] = '\0';
    
    m_pFile = FileOpen(filename, "rb");
    POINTERS_EQUAL(NULL, m_pFile);
}

TEST(FileOpen, AttemptToOpenAFilenameThatIsTooLong)
{
    char filename[1+1+257+1];
    
    memset(filename, 'a', sizeof(filename));
    filename[1] = PATH_SEPARATOR;
    filename[259] = '\0';
    
    m_pFile = FileOpen(filename, "rb");
    POINTERS_EQUAL(NULL, m_pFile);
}